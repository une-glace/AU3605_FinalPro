# 血管区域光滑填充（擦除与修补）汇报材料

---

## 部分一：详细流程讲稿（可 5–6 分钟展开）

这一部分是“血管区域光滑填充”模块的完整讲稿，主要对应代码 `vessel_inpaint.py`，适合老师追问实现细节或你需要讲得更深入时使用。

### 1. 任务背景与整体目标

在前面的血管分割模块中，我们已经可以从眼底图像中得到一张较为准确的血管二值掩膜。接下来这个模块的目标，是在血管区域内做**光滑填充**：

- 利用血管分割结果，自动找到所有血管像素；
- 用图像修补（inpainting）的方法，将这些血管像素替换为周围背景的合理推断；
- 得到一张“去血管”的眼底图。

这样做的动机是：在一些异常检测或病灶分析任务中，血管结构本身会成为干扰。比如亮斑、出血等病灶往往出现在血管附近，如果直接在原图上建模，很难区分“正常血管高亮”与“病灶高亮”。通过先分割再擦除血管，我们可以给后续模块提供一个更加干净、平滑的背景，提高对异常结构的敏感度。

### 2. 整体流程概览

血管区域光滑填充的整体流程可以概括为四步：

1. 加载训练好的血管分割网络 `VesselSegNet`；
2. 对输入眼底图预测血管掩膜，并根据需要进行膨胀；
3. 使用 OpenCV 的 `inpaint` 算法在掩膜区域内进行图像修补；
4. 将原图、血管预测叠加图、修补后的图像拼成三联图，输出到结果目录。

对应代码集中在 `vessel_inpaint.py` 的 `main` 函数和若干辅助函数中。

### 3. 模型加载与设备选择

在 `vessel_inpaint.py` 中，首先通过命令行参数指定：

- `--input-dir`：输入图像目录，默认是 `dataset/Vessel/test`，如果目录下有 `images` 子目录，会自动定位到其中；
- `--output-dir`：输出结果目录，默认是 `results_vessel_inpaint`；
- `--model-path`：血管分割模型路径，默认是 `logs/vessel_seg_model_best.pth`；
- `--device`：运行设备，支持 `auto`、`cpu`、`cuda`；
- 以及若干用于控制掩膜膨胀、修补半径和可视化透明度的参数。

在 `main` 中：

1. 将相对路径转换为绝对路径，并检查输入目录与模型文件是否存在；
2. 根据 `device` 参数和本机是否有可用 GPU，选择在 CPU 或 GPU 上运行；
3. 调用 `_load_model`：
   - 构造一个与训练阶段一致的 `VesselSegNet`；
   - 从 `model_path` 加载权重，并自动去掉可能存在的 `module.` 前缀；
   - 将模型移动到指定设备并设置为评估模式。

这样，我们就复用了前一部分训练好的血管分割网络，作为本模块的“血管检测器”。

### 4. 预测血管掩膜与膨胀处理

接下来是对每张输入图像的处理流程。

1. **遍历输入图像**  
   - 使用 `_list_images` 列出输入目录中的所有图像文件（支持 jpg、png、bmp、tif、ppm 等常见格式）；
   - 可以通过 `--limit` 参数限制处理前若干张图，方便调试。

2. **预测血管掩膜 `_predict_mask`**  
   - 对每一张读入的 BGR 图像：
     - 先缩放到 `img_size×img_size`（默认 256×256），并归一化到 `[0, 1]`；
     - 转换为 `C×H×W` 的张量，加 batch 维度后送入 `VesselSegNet`；
     - 通过 `sigmoid` 得到概率图，再用 `threshold`（默认 0.5）转为 0/1 掩膜；
     - 再将掩膜缩放回原图尺寸，得到与原图同大小的二值血管 mask。

3. **膨胀掩膜以扩大擦除区域**  
   - 在很多情况下，仅仅去掉分割预测为“血管”的像素可能不够，因为血管周围一圈的像素也会感受到血管结构的影响；
   - 为了避免残留细线或边缘，我们引入了一个可选的“膨胀”步骤：
     - 参数 `--dilate` 用来控制膨胀半径，默认值为 2；
     - 如果 `dilate > 0`，我们构造一个椭圆形结构元素，并用 `cv2.dilate` 对掩膜进行一次膨胀；
   - 得到的 `mask_inpaint` 就是最终用于 inpaint 的掩膜，它比原始预测掩膜略粗一些。

通过这一步，所有需要被“擦除”的血管区域在掩膜中被标记出来，并适当放大，保证后续修补更加彻底和平滑。

### 5. 图像修补（Inpainting）算法

有了血管掩膜之后，核心问题就变成了：如何在这些被标记的区域内进行合理的填充，使填补后的图像既没有明显孔洞，又尽量保持原始结构的连续性。

在实现上，我们使用 OpenCV 提供的 `cv2.inpaint` 函数，它支持两种经典的修补算法：

1. **Telea 方法**（默认）：  
   - 对应参数 `INPAINT_TELEA`，是一种基于快速行进法（fast marching method）的图像修补方法；
   - 思路是从掩膜边界向内逐步推进，用“已知区域”的信息来推断“未知区域”的颜色；
   - 对小区域的修补效果比较自然，保边性较好，速度也较快。

2. **Navier-Stokes 方法**：  
   - 对应参数 `INPAINT_NS`，基于类流体力学的偏微分方程；
   - 更强调在结构和边缘方向上的连续性；
   - 对某些细长结构的延展效果更好，但计算量略大。

在命令行中可以通过 `--inpaint-method telea/ns` 选择具体算法，默认使用 `telea`。

修补调用流程如下：

- 根据膨胀后的掩膜 `mask_inpaint` 构造 OpenCV 需要的 `inpaint_mask`：  
  - 将掩膜中的 1 转为 255，其余为 0；
- 调用 `cv2.inpaint`：
  - 传入原始 BGR 图像、`inpaint_mask`、修补半径 `inpaint_radius` 和具体算法类型；
  - 得到一张新的 `inpainted` 图像，其中原来血管位置被周围背景平滑填充。

修补半径决定了算法在多大范围内参考周围的信息，默认值为 3，可以根据效果适当调整。

### 6. 可视化三联图：原图 / 血管覆盖 / 修补结果

为了在汇报时直观展示“血管擦除”的效果，我们在代码中生成了一张三联图，把三个关键结果拼接在一起：

1. **原图**  
   - 直接使用原始 `img_bgr`；
   - 通过 `_add_title` 在左上角加上 “Original” 文字标题。

2. **血管预测覆盖图**  
   - 在原图基础上叠加血管预测掩膜：
     - 使用 `_overlay_mask_alpha`，在掩膜为 1 的区域，将原图颜色与红色 `(0, 0, 255)` 按给定透明度 `overlay_alpha` 混合；
   - 得到一张带有红色半透明血管标记的图；
   - 同样用 `_add_title` 标注标题 “Vessels (Pred)”。

3. **修补结果图**  
   - 使用 inpaint 得到的 `inpainted` 图像；
   - 用 `_add_title` 加标题 “Inpainted”。

最终，将这三张图沿宽度方向 `np.concatenate` 拼接成一张宽图，并保存到输出目录：

- 文件名为 `原图文件名 + _vessel_inpaint.jpg`，例如 `01_test_vessel_inpaint.jpg`；
- 默认保存位置为 `results_vessel_inpaint`。

这一三联图可以直接用于 PPT 展示，可以非常直观地对比“原始含血管”、“血管检出位置”、“血管擦除后的结果”。

### 7. 模块在整体系统中的作用

血管区域光滑填充是整个系统中承上启下的一步：

- 它依赖于前一步血管分割的结果来构造修补掩膜；
- 它输出的“去血管图像”可以作为后续异常检测、病灶识别的输入，减少血管结构的干扰；
- 同时，三联图也为我们提供了一个很直观的可视化手段，方便调试和展示“血管分割 + 擦除”这一整条流程。

从系统角度来看，这一步体现了“分割结果如何服务于后续任务”的思路，而不是把分割停留在一张掩膜图上。

---

## 部分二：2–3 分钟精简讲稿

这一部分是可以在答辩时直接照读的版本，长度控制在 2–3 分钟。

---

大家好，最后我简单介绍一下我们在血管分割之后做的一个处理：血管区域的光滑填充，也可以理解为血管擦除。

前面的模块已经能够从眼底图中分割出较为准确的血管掩膜。但是在做异常检测或者某些病灶分析时，血管本身往往是一个强干扰因素。很多亮斑或者出血都发生在血管附近，如果直接在原图上建模，很难区分“正常血管的高亮”与“真正的病灶”。因此，我们希望在保持背景结构连续性的前提下，把血管区域擦除掉，得到一张干净的眼底背景图。

具体来说，我们在 `vessel_inpaint.py` 中基于已经训练好的 `VesselSegNet` 做了这样几步处理：

第一步，用血管分割网络对输入眼底图预测血管掩膜。我们先把图像缩放到固定大小，送入网络得到每个像素是血管的概率，再用阈值把它转成二值掩膜，并缩放回原图大小。为了让擦除更彻底，我们还对掩膜做了一次膨胀，把血管周围一圈的像素也包含进来。

第二步，在血管掩膜区域内做图像修补，也就是 inpainting。我们使用 OpenCV 提供的两种经典修补算法，默认使用 Telea 方法。它的作用是从掩膜边界向内逐步填充，用周围的颜色和纹理信息来推断被擦除区域的内容。通过合适的修补半径设置，可以在去掉血管的同时，保持背景结构的平滑和连贯。

第三步，为了便于展示和对比，我们为每张图生成了一张三联图：左边是原始眼底图，中间是在原图上用红色半透明叠加的血管预测结果，右边是做完 inpaint 之后的“去血管图像”。这些结果保存在 `results_vessel_inpaint` 目录，可以直接放到 PPT 里，让老师直观地看到血管从“有 → 标记 → 擦除”的整个过程。

这个血管擦除模块把前面血管分割的结果真正用到了后续任务中。一方面，它提供了更干净的背景，有利于后续异常检测模块集中关注病灶本身；另一方面，也体现了我们不是只停留在分割指标上，而是把各个模块串联起来，为最终的诊断分析服务。

---

## 部分三：PPT 制作建议

这一部分是针对“血管区域光滑填充”章节的 PPT 设计建议，可以按 2–3 页来做。

### 第 1 页：任务与动机

- 标题：  
  - `血管区域光滑填充：为什么要擦除血管？`

- 左侧图片：  
  - 放一张含有明显血管和病灶的原始眼底图，可以从 `dataset/Vessel/test/images` 或其他数据集中选取；
  - 橙色或红色圈出一块病灶附近区域（可在 PPT 里手动画圈），强调血管对观察的干扰。

- 右侧文字要点：  
  - `• 血管结构在视觉上非常显眼，容易掩盖或干扰病灶`  
  - `• 直接在原图上做异常检测，难以区分“血管高亮”和“病灶高亮”`  
  - `• 目标：在保持背景结构平滑的前提下，擦除血管，得到干净的眼底背景`

讲解时：用这页回答“为什么要做血管擦除”这个问题，强调它是为后续异常检测服务的。

### 第 2 页：方法流程与 inpaint 算法

- 标题：  
  - `血管擦除方法：分割掩膜 + 图像修补`

- 中间流程图：  
  - 用一条简单的流程表示整个管线：
    - `输入眼底图 → 血管分割网络 → 血管掩膜（可膨胀） → inpaint 修补 → 去血管图像`
  - 在“血管掩膜”旁边可以画一个小图标，显示黑底白线的血管二值图；
  - 在“inpaint 修补”旁边注明“OpenCV inpaint（Telea / NS）”。

- 右侧文字要点：  
  - `• 利用训练好的 VesselSegNet 预测血管掩膜`  
  - `• 对掩膜进行适度膨胀，扩大擦除区域`  
  - `• 使用 OpenCV inpaint 在掩膜内进行平滑填充，恢复背景`

讲解时：顺着流程图讲三步：预测掩膜、膨胀、修补，对应精简讲稿中的主要内容。

### 第 3 页：三联图结果展示

- 标题：  
  - `血管擦除效果：原图 / 预测 / 修补`

- 图片区域（核心展示）：  
  - 直接从 `results_vessel_inpaint` 目录中选几张典型的三联图，例如：
    - `01_test_vessel_inpaint.jpg`、`02_test_vessel_inpaint.jpg` 等；
  - 每张图左中右分别是：
    - Original：原始眼底图；  
    - Vessels (Pred)：原图上用红色半透明显示预测血管；  
    - Inpainted：血管区域被平滑填充后的图像。

- 下方或右侧文字要点：  
  - `• 左：原始含血管眼底图`  
  - `• 中：预测的血管位置（红色叠加）`  
  - `• 右：擦除血管后的图像，背景结构更平滑`  
  - `• 为后续异常检测和病灶识别提供干净背景`

讲解时：可以让老师先看左图，再看中图“哪些地方被认为是血管”，最后看右图“这些血管被填平之后，背景变得更干净、更适合异常检测”。

如果整体时间有限，也可以只保留第 2 和第 3 页，把“动机”部分压缩到方法页的右侧文字中，用一两句话带过即可。

